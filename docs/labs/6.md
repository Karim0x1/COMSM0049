# LAB 7: Sandboxing for Security

# Why do we need sandboxing?

There are many different techniques to sandbox programs, some of them are isolation-based mechanisms such as docker, and some are application based, such as seccomp, pledge, and unveil. Application-oriented sandboxes are designed to limit the process's access to system resources, such as filtering the system calls that a process is allowed to run, or restricting the files that a process can read and write to. These mechanisms help in implementing the least privileged principle, where the process is only given privileges that are needed to complete its task and nothing more. This help in reducing the damage in case the process was compromised. In this lab, we will be looking at different sandboxing mechanisms, seccomp, chroot, pledge, and unveil.

And of course, there is an xkcd for it :)

![](https://i.imgur.com/GQiU3e6.png)


# Seccomp

Seccomp (short for secure computing) is a security mechanism provided by Linux as a sandboxing technique for processes to limit what system calls a process can run. Seccomp can be used in two modes, strict mode, and filter mode, in this lab, we will focus on the filter mode. Filter mode allows the filtering of system calls (white listing and black listing certian system calls) using a configurable policy implemented using Berkeley Packet Filter rules (BPF). However, writing BPF filters is tricky and requires writing assembly code. Gladly, there is a library that makes using seccomp much easier, we will be using libseccomp library in this lab to sandbox a C program and allow/disallow certain system calls. Documentation for libseccomp can be found [here](https://libseccomp.readthedocs.io/en/latest/).

# Material

**Vagrantfile**
```
Vagrant.configure("2") do |config|
  config.vm.box = "generic/debian10"
  config.vm.synced_folder ".", "/vagrant"
  config.vm.provision "shell", inline: "sudo apt-get update --yes"
  config.vm.provision "shell", inline: "sudo apt-get install --yes strace build-essential libseccomp-dev"
end
```

**sandbox.c**
```C
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <seccomp.h>

#define GREEN "\x1B[32m"
#define RESET "\x1B[0m"

// ADD YOUR CODE HERE
void create_sandbox(){
  scmp_filter_ctx ctx;
  ctx = seccomp_init(SCMP_ACT_ALLOW);
  seccomp_load(ctx);
}

void read_file(){
  char buf[6];
  int fd = open("/dev/urandom",O_RDONLY);
  size_t n = read(fd, buf, 5);
  if(n==5){
    printf("Read from /dev/urandom is %sdone%s\n",GREEN,RESET);
  }
  close(fd);
}

void write_file(){
  char* buf = "testing";
  int fd = open("/dev/null",O_WRONLY);
  size_t n = write(fd, buf, 1);
  if(n==1){
    printf("Write to /dev/null is %sdone%s\n",GREEN,RESET);
  } 
  close(fd);
}

void get_process_id(){
  int pid = getpid();
  printf("Current process id is %s%d%s\n",GREEN,pid,RESET);
}

void run_untrusted_code(){
  read_file();
  write_file();
  get_process_id();
  printf("%sProgram finished successfully\n%s",GREEN,RESET);
}

int main(){
  create_sandbox();
  run_untrusted_code();
  return 0;
}
```
This given program writes to a file, reads from a file, and outputs the process Id. In this lab, you will be asked to use different sandboxing mechanisms to limit what this program is allowed to do.

# Task 1
You will be implementing the sandbox in create_sandbox function. Compile the C program and answer the following questions: 

`gcc sandbox.c -lseccomp -o sandbox` 

* What happens when you run the program?
* Use strace to monitor what system calls the program executes.
* What does seccomp_init function do, and what parameters does it take? Use the man pages to find this information `man seccomp_init`.
* What is `SCMP_ACT_ALLOW` parameter?

# Task 2
Let's try to restrict all system calls (prevent the program from running any system call) using seccomp

* Replace `SCMP_ACT_ALLOW` with another parameter to disallow all system calls. Use the help of man pages.
* Use strace to figure out what system call causes the program to crash.

# Task 3
* Use `seccomp_rule_add` function to add a filter rule to allow only read_file and write_file functions to complete successfully.
Use the help of man pages `man seccomp_rule_add`, there are examples at the bottom of the page that will help you.
* Configure seccomp to allow all functions (read_file, write_file, get_process_id) to run successfully.

# Task 4
Let's test what we know so far

* Can we inspect the system call parameters using seccomp? If no, can you figure out why?
* Can we limit access to certain files using seccomp?

# Pledge and Unveil

# Material

**Vagrantfile**
```
Vagrant.configure("2") do |config|
  config.vm.box = "generic/openbsd6"
  config.vm.synced_folder ".", "/vagrant"
end
```

In OpenBSD land, pledge and unveil provide similar functionality to seccomp in Linux. Pledge takes a list of promises, these promises map to a group of system calls or specific system functionality. On the other hand, unveil system call is used to restrict process resources in terms of file system access. A program calling unveil with a specified path is only allowed to access files under that path.

**Notes:** 
* Before compiling the program, remove any seccomp related code. 
* To compile the program in openbsd run `gcc sandbox.c`.
*  strace is not avliable in OpenBSD, however, there are simillar alternatives, such as ktrace and kdump.

# Task 5

We will be working with the same program above but this time using pledge and unveil. Remove any seccomp-related code and try to solve the following tasks.

* Use pledge system call to only read_file and write_file functions to run successfully.
Read the man page of pledge `man pledge` to know which promises to use to achieve the task.
# Task 6
* Use pledge system call to allow all functions in the program to run successfully.
# Task 7
* Use unveil system call to restrict access to only /home folder.
Read the man page of unveil `man unveil`.

# Chroot

This mechanism is very old, it was added to Linux in 1979! chroot stands for change root, this technique was never intended to be used as a security mechanism, it was created for debugging purposes, but unfortunately, it has been widely used to sandbox programs and still to this day.
chroot simply works by rebasing the root directory of the sandboxed process, so if a process is in a chroot sandbox, the process will think that the root directory of the system is the directory of the chroot sandbox instead of the actual root directory of the system (/), and thus, the process can not simply access files outside the sandbox by using commands such as `cd ..`. 
However, since chroot was not designed for security, it can be bypassed in many ways. In this section of the lab, you will use chroot and then escape it!

![](https://i.imgur.com/QU7skJm.jpg)


# Material

To use chroot, you can use the same vagrant machine of the first exercise.

**jailed_process.c**
```C
#include <stdio.h>
#include <dirent.h> 

#define GREEN "\x1B[32m"
#define RESET "\x1B[0m"

void ls(){
  printf("%sCurrent files and directories in /%s\n",GREEN,RESET);
  DIR *d;
  struct dirent *dir;
  d = opendir("/");
  if (d) {
    while ((dir = readdir(d)) != NULL) {
      printf("%s\n", dir->d_name);
    }
    closedir(d);
  }
}

void escape_sandbox(){
  
}

int main(){
  ls();
  return 0;
}
```

This program has `ls` function, which list files in the root directory. 

* Compile this program and run it. Make a note of the files that it lists.

`gcc --static jailed_process.c -o jailed_process`


# Task 8

Let's put this program in a chroot jail and run it there.

chroot command line program takes two parameters, a directory for the chroot jail, and a program to run inside the jail.

```bash
# create the jail directory
mkdir -p jail/home
# copy the program to the jail directory
cp jailed_process jail/home
# run chroot (need sudo)
sudo chroot jail /home/jailed_process
```

* Was the output different from when you run the program outside the jail?
* Can you figure out why we needed to compile the program statically?

# Task 9
 Each process in Linux has two properties, the root directory and the current working directory (cwd). You can examine these directories for the current process as follows:
```bash
ls /proc/$$/cwd
ls /proc/$$/root
```
To change the current working directory of a process, you can use `chdir` system call. 
To change the root directory of a process, you can use `chroot` system call.

**Note**
chroot command line tool is different from chroot system call. chroot command line tool runs chroot system call to change the root directory to the specified jail directory, and ***then***, it runs chdir system call to change the cwd to the jail directory. The chroot system call does ***not***  change the cwd of the jailed process. (This difference is very important and you will need to understand it to be able to escape chroot jail).

* Use the information above to escape the chroot jail, write your code in `escape_sandbox` function. 

**Hint**
To escape the jail, you need to use a combination of mkdir, chroot, and a number of chdir system calls. 

# chroot for debugging?
I mentioned before that chroot was created initially for testing and debugging purposes, let's say that your computer powered off while installing kernel updates, and then when you turned it back on, a kernel panic happened because the updates were not installed successfully. To solve such an issue, you can boot from a live image of the OS, mount the root partition, chroot to it, and then continue your updates or fix the issue.

# If you play CTFs
I love CTFs, here is an interesting hackthebox machine that involves escaping chroot jail :) [HackTheBox - Scanned ](https://www.youtube.com/watch?v=FoQuNsCyQz0)

# Read more about Capsicum
We touched on seccomp in Linux, and pledge and unveil in OpenBSD, however, in FreeBSD, there is capsicum.
Capsicum is another sandboxing mechanism that aims to achieve somewhat similar goals to seccomp and pledge. It combines capabilities with file descriptors (not just files!) to limit the resources a program can access and use.

# Read more about Qubes OS
>  If you're serious about security, QubesOS is the best OS available today. It's what I use, and free. Edward Snowden
>  
Qubes OS is a security-oriented operating system, it uses virtual machines to isolate untrusted code and processes. It uses Linux Xen lightweight virtual machines to isolate process and different environments. If one of these components were to become comprimised, the malicious programme would only be able to access the data present in the comprimise environments.
